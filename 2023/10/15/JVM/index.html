<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JVM摘要主要记录JVM中，字节码、Class文件、类加载机制、运行时内存、堆、方法区、对象的内存布局等知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2023/10/15/JVM/index.html">
<meta property="og:site_name" content="baiyin’s blog">
<meta property="og:description" content="JVM摘要主要记录JVM中，字节码、Class文件、类加载机制、运行时内存、堆、方法区、对象的内存布局等知识。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403120010996.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403120021587.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403151159175.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403200942780.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403170903172.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403170936348.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403171054423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403200942146.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403201340054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211045799.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403201530865.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211040517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211256629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211257951.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211449217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211453112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211511295.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211518821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211524465.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403230926137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231618416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231609671.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231610941.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231631020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231914792.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251828909.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251855790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251857199.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251924323.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251923096.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261712182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261754315.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261808361.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261926363.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261927932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261927965.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261932444.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261943930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261939744.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261954985.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261955908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261955632.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403262021178.png">
<meta property="article:published_time" content="2023-10-15T02:15:00.000Z">
<meta property="article:modified_time" content="2024-11-09T16:10:13.511Z">
<meta property="article:author" content="baiyina">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403120010996.png">


<link rel="canonical" href="http://example.com/2023/10/15/JVM/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/10/15/JVM/","path":"2023/10/15/JVM/","title":"JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM | baiyin’s blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">baiyin’s blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">"Talk is cheap. Show me the code."</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E9%87%8C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">字节码文件里是什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">生成字节码的编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E6%9C%89Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.</span> <span class="nav-text">哪些类型有Class对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.3.</span> <span class="nav-text">什么是字节码指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">Class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AD%94%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">魔数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.3.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">字面量和符号引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">符号引用和直接引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java虚拟机中，数据类型可以分为哪几类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%94%BE%E5%A0%86%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">为什么不把基本类型放堆中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E6%8C%87%E9%92%88"><span class="nav-number">1.4.3.</span> <span class="nav-text">Java中有没有指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">1.4.4.</span> <span class="nav-text">Java的参数传递是值传递还是引用传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%BD%A2%E5%8F%82"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">实参与形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">值传递和引用传递</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loading%EF%BC%88%E8%A3%85%E8%BD%BD%EF%BC%89"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">loading（装载）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.1.2.1.</span> <span class="nav-text">二进制流的获取方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%9C%A8%E5%93%AA"><span class="nav-number">1.5.1.2.2.</span> <span class="nav-text">Class实例的位置在哪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.5.1.2.3.</span> <span class="nav-text">数组类的加载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linking-%E9%93%BE%E6%8E%A5"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Linking 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-Verification"><span class="nav-number">1.5.1.3.1.</span> <span class="nav-text">验证 Verification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87-Preparation"><span class="nav-number">1.5.1.3.2.</span> <span class="nav-text">准备 Preparation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-Resolution"><span class="nav-number">1.5.1.3.3.</span> <span class="nav-text">解析 Resolution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Initialization-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Initialization 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E4%B8%8D%E4%BC%9A%E7%94%9F%E6%88%90clinit%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.5.1.4.1.</span> <span class="nav-text">哪些类不会生成clinit方法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-final%E6%90%AD%E9%85%8D%E6%97%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E4%B8%8D%E7%94%9F%E6%88%90clinit%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.1.4.2.</span> <span class="nav-text">static final搭配时不一定不生成clinit方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#clinit-%E6%96%B9%E6%B3%95%E6%9C%89%E5%B8%A6%E9%94%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86"><span class="nav-number">1.5.1.4.3.</span> <span class="nav-text">&lt; clinit &gt;方法有带锁线程安全处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.1.4.4.</span> <span class="nav-text">类的初始化情况，主动使用和被动使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.1.4.5.</span> <span class="nav-text">主动使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unloading-%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Unloading 卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.1.5.1.</span> <span class="nav-text">类、类的加载器、类的实例之间的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B1%BB%E4%BC%9A%E8%A2%AB%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.5.1.5.2.</span> <span class="nav-text">什么情况下类会被卸载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD%E5%9C%A8%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.5.1.5.3.</span> <span class="nav-text">类卸载在实际生产中的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.5.1.5.4.</span> <span class="nav-text">方法区的垃圾回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ClassLoader%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">ClassLoader的作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">类的显式加载和隐式加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">类加载机制的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E5%90%97"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">加载的类是唯一的吗</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">1.类的唯一性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.2.4.2.</span> <span class="nav-text">2.命名空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">类加载机制的基本特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">1.5.3.</span> <span class="nav-text">类加载器的分类和测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E8%AF%B4%E6%98%8E"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">类加载器的分类说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">子父类加载器的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">具体类加载器介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">1.5.3.3.1.</span> <span class="nav-text">启动类加载器（引导类加载器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.5.3.3.2.</span> <span class="nav-text">扩展类加载器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">1.5.3.3.3.</span> <span class="nav-text">应用程序类加载器（系统类加载器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.5.3.3.4.</span> <span class="nav-text">用户自定义类加载器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">1.5.4.</span> <span class="nav-text">ClassLoader源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E8%AF%B4%E6%98%8E-1"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">类加载器的分类说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.5.5.</span> <span class="nav-text">自定义类的加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.6.</span> <span class="nav-text">双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">优势和劣势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">1.5.6.2.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.5.6.2.2.</span> <span class="nav-text">劣势</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">破坏双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1"><span class="nav-number">1.5.6.3.1.</span> <span class="nav-text">第一次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1"><span class="nav-number">1.5.6.3.2.</span> <span class="nav-text">第二次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1"><span class="nav-number">1.5.6.3.3.</span> <span class="nav-text">第三次</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98"><span class="nav-number">1.6.</span> <span class="nav-text">运行时内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.6.2.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A0%88%E7%AE%A1%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%A0%86%E7%AE%A1%E5%AD%98%E5%82%A8"><span class="nav-number">1.6.2.1.1.</span> <span class="nav-text">如何理解栈管运行，堆管存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%9C%A8GC%E5%90%97"><span class="nav-number">1.6.2.1.2.</span> <span class="nav-text">栈中存在GC吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E4%BC%9A%E7%88%86%E5%87%BA%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.2.1.3.</span> <span class="nav-text">栈会爆出什么异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E4%BC%9A%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%91%E7%94%9F%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.6.2.1.4.</span> <span class="nav-text">栈会在什么情况下发生栈内存溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E4%B8%AD%EF%BC%8C%E6%A0%88%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E5%8F%82%E6%95%B0%E6%9D%A5%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.6.2.1.5.</span> <span class="nav-text">Java中，栈的大小通过什么参数来设置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84FILO%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">栈的FILO原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">栈帧的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.6.2.3.1.</span> <span class="nav-text">局部变量表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.6.2.3.1.1.</span> <span class="nav-text">静态变量和局部变量的对比</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#GC-Roots"><span class="nav-number">1.6.2.3.1.2.</span> <span class="nav-text">GC Roots</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Slot"><span class="nav-number">1.6.2.3.1.3.</span> <span class="nav-text">Slot</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-number">1.6.2.3.2.</span> <span class="nav-text">操作数栈</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">1.6.2.3.2.1.</span> <span class="nav-text">栈顶缓存技术</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89"><span class="nav-number">1.6.2.3.3.</span> <span class="nav-text">动态链接（指向运行时常量池的方法引用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">1.6.2.3.4.</span> <span class="nav-text">方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">问题和小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.6.2.4.1.</span> <span class="nav-text">栈溢出的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="nav-number">1.6.2.4.2.</span> <span class="nav-text">分配的栈内存越大越好吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.6.2.4.3.</span> <span class="nav-text">垃圾回收是否会涉及到虚拟机栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.6.2.4.4.</span> <span class="nav-text">方法中定义的局部变量是否线程安全</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.7.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">核心概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="nav-number">1.7.1.0.1.</span> <span class="nav-text">对象都分配在堆上？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.2.</span> <span class="nav-text">堆的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">年轻代和老年代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">如何设置堆内存的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E4%BE%8B"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">新生代和老年代的比例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Eden%EF%BC%8C%E5%B9%B8%E5%AD%98%E8%80%85%E5%8C%BA%E6%AF%94%E4%BE%8B"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">Eden，幸存者区比例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E9%87%91%E5%8F%A5"><span class="nav-number">1.7.4.</span> <span class="nav-text">对象分配金句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">内存分配原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%89%96%E6%9E%90"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">过程剖析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8AMinor-GC-Major-GC-Full-GC"><span class="nav-number">1.7.5.</span> <span class="nav-text">详细解释Minor GC, Major GC, Full GC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">Minor GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Major-GC"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">Major GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Full-GC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">1.7.5.4.</span> <span class="nav-text">Full GC触发机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%BB%A3"><span class="nav-number">1.7.6.</span> <span class="nav-text">为什么要分代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLAB"><span class="nav-number">1.7.7.</span> <span class="nav-text">TLAB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.8.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">栈、堆、方法区的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">1.8.1.</span> <span class="nav-text">方法区在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.8.2.</span> <span class="nav-text">方法区的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.8.3.</span> <span class="nav-text">HotSpot中方法区的演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%8E%E5%85%83%E7%A9%BA%E9%97%B4"><span class="nav-number">1.8.4.</span> <span class="nav-text">永久代与元空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%A2%AB%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">永久代为什么要被元空间替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.9.</span> <span class="nav-text">对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.9.1.</span> <span class="nav-text">对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">创建对象的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#new"><span class="nav-number">1.9.1.1.1.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Class%E7%9A%84newInstance"><span class="nav-number">1.9.1.1.2.</span> <span class="nav-text">Class的newInstance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructor%E7%9A%84newInstance-Xxx"><span class="nav-number">1.9.1.1.3.</span> <span class="nav-text">Constructor的newInstance(Xxx)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Clone%EF%BC%88%EF%BC%89"><span class="nav-number">1.9.1.1.4.</span> <span class="nav-text">使用Clone（）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.9.1.1.5.</span> <span class="nav-text">使用反序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93Objenesis"><span class="nav-number">1.9.1.1.6.</span> <span class="nav-text">第三方库Objenesis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">创建对象的步骤</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="baiyina"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">baiyina</p>
  <div class="site-description" itemprop="description">莫道君行早，更有早行人</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/baiyina" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;baiyina" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:baiyinaGuo@gmail.com" title="E-Mail → mailto:baiyinaGuo@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/15/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="baiyina">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baiyin’s blog">
      <meta itemprop="description" content="莫道君行早，更有早行人">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM | baiyin’s blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-15 10:15:00" itemprop="dateCreated datePublished" datetime="2023-10-15T10:15:00+08:00">2023-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-10 00:10:13" itemprop="dateModified" datetime="2024-11-10T00:10:13+08:00">2024-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>40 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>主要记录JVM中，字节码、Class文件、类加载机制、运行时内存、堆、方法区、对象的内存布局等知识。</p>
<span id="more"></span>

<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h4 id="字节码文件里是什么"><a href="#字节码文件里是什么" class="headerlink" title="字节码文件里是什么"></a>字节码文件里是什么</h4><p>源代码经过编译器编译就会生成字节码文件class，字节码文件是一种二进制的类文件，它的内容是JVM的指令，不是像c语言由编译器直接生成机器码。</p>
<h3 id="生成字节码的编译器"><a href="#生成字节码的编译器" class="headerlink" title="生成字节码的编译器"></a>生成字节码的编译器</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403120010996.png" alt="image-20240312000940738"></p>
<p>javac就是一个全量的前端编译器</p>
<p>前端编译器的主要任务就是负责将符合java语法规范的Java代码转换成符合JVM规范的字节码文件</p>
<p>前端编译器不涉及编译优化，这些具体的细节会交给HotSpot的JIT编译器。</p>
<h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a>哪些类型有Class对象</h3><ol>
<li><p>class</p>
<p>外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</p>
</li>
<li><p>interface</p>
<p>接口</p>
</li>
<li><p>[]</p>
<p>数组</p>
</li>
<li><p>enum：枚举</p>
</li>
<li><p>annotation：注解@interface</p>
</li>
<li><p>primitive type：基本数据类型（预加载）</p>
</li>
<li><p>void</p>
</li>
</ol>
<h3 id="什么是字节码指令"><a href="#什么是字节码指令" class="headerlink" title="什么是字节码指令"></a>什么是字节码指令</h3><p>Java虚拟机指令有一个字节长度的、代表着某种特定操作含义的操作码以及跟随其后的灵芝多个代表此操作所需参数的操作数所构成，虚拟机中的许多指令并不包含操作数，只有一个操作码。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403120021587.png" alt="image-20240312002152709"></p>
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><ul>
<li>魔数</li>
<li>Class文件版本</li>
<li>常量池</li>
<li>访问标识（或标志）</li>
<li>类索引，父类索引，接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>Class文件的标识</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池是一种表结构，以1~constant_pool__count - 1为索引。</p>
<p>表明了后面有多少个常量项。</p>
<p>常量池主要存放两大类常量：字面量和符号引用。</p>
<p>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。</p>
<h4 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h4><table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
</tr>
<tr>
<td></td>
<td>声明为final的常量值</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
</tr>
</tbody></table>
<h3 id="符号引用和直接引用"><a href="#符号引用和直接引用" class="headerlink" title="符号引用和直接引用"></a>符号引用和直接引用</h3><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</p>
<p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能简介定位到目标的句柄。直接引用时与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>
<p>Java代码子进行Javac编译的时候，并不像C和C++一样有“连接”这一步骤，而是在虚拟机中加载Class文件地时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这新字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法被虚拟机使用。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类创建的时候或运行时解析、翻译到具体的内存地址之中</p>
<p>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得相应的符号引用，再在类加载的过i城中解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Java虚拟机中，数据类型可以分为哪几类？"><a href="#Java虚拟机中，数据类型可以分为哪几类？" class="headerlink" title="Java虚拟机中，数据类型可以分为哪几类？"></a>Java虚拟机中，数据类型可以分为哪几类？</h3><p>Java虚拟机是通过某些数据类型来执行计算的，数据类型可以分为两种，基本类型和引用类型，基本类型的变量持有原始值，而引用类型的变量持有引用值。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403151159175.png" alt="image-20240315115906865"></p>
<p><strong>Java语言中的所有基本类型同样也都是Java虚拟机中的基本类型</strong>，但是boolean有些特别，虽然Java虚拟机也把boolean看做基本类型，但是<strong>指令集对boolean只有很有限的支持，当编译器把Java源代码编译为字节码时，他会用int或者byte来表示boolean</strong>。在Java虚拟机中，false是由整数零来表示的，所有非零整数多表示true，<strong>涉及boolean值的操作则会使用in</strong>t，另外，<strong>boolean数组是当作byte数组</strong>来访问的。<img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403200942780.png" alt="image-20240315151816696">_w指令需要使用到的，它的<strong>值是JVM指令的操作码的指针</strong>。returnAddress不是简单意义上的数值，<strong>不属于任何一种基本类型，并且它的值是不能被永兴中的程序所修改的。</strong></p>
<p><strong>Java虚拟机的引用类型同称为“引用”</strong>，有三种引用类型：<strong>类类型，接口类型、以及数组类型</strong>，他们的值都是<strong>对动态创建对象的引用</strong>。<strong>类类型的值是对类实例的引用</strong>；<strong>数组类型的值是对数组对象的引用</strong>，在Java虚拟机中，数组是个真正的对象；而<strong>接口类型的值，则是对实现类该接口的某个类实例的引用</strong>。还有一种特殊的<strong>引用值是null，他表示该引用变量没有引用任何对象</strong>。</p>
<h3 id="为什么不把基本类型放堆中？"><a href="#为什么不把基本类型放堆中？" class="headerlink" title="为什么不把基本类型放堆中？"></a>为什么不把基本类型放堆中？</h3><p>首先是堆和栈的特点不同，堆比栈大，但是<strong>栈比堆的运算速度要快</strong></p>
<p><strong>将复杂数据类型放在堆中的目的是为了不影响栈的效率，而是通过引用的方式去堆中查找，八大基本类型的大小创建的时候已经确立，三大引用类型创建时无法  确定大小</strong></p>
<p><strong>简单数据类型比较稳定和，并且它只占据很小的内存，将它放在空间小、运算速度快的栈中，能够提高效率。</strong></p>
<h3 id="Java中有没有指针"><a href="#Java中有没有指针" class="headerlink" title="Java中有没有指针"></a>Java中有没有指针</h3><p>没有，取消了指针的概念，因为一些操作会造成不必要的风险。</p>
<h3 id="Java的参数传递是值传递还是引用传递"><a href="#Java的参数传递是值传递还是引用传递" class="headerlink" title="Java的参数传递是值传递还是引用传递"></a>Java的参数传递是值传递还是引用传递</h3><p><strong>Java只有值传递，没有引用传递</strong></p>
<h4 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a>实参与形参</h4><p>形式参数：实在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数</p>
<p>实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数</p>
<h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p><strong>值传递</strong>：将参数复制一份，修改形参不会对实参造成影响</p>
<p><strong>引用传递</strong>：将实参的地址传递给形参，修改形参也就是在修改实参。</p>
<p>演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhangguoa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/3/17 9:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().pass(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;main: &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pass</span> <span class="params">(StringBuilder str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pass: &quot;</span> +  str);</span><br><span class="line">        str.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pass: zhangsan</span><br><span class="line">main: nasgnahz</span><br></pre></td></tr></table></figure>

<p>看起来是改变了str的值，其实不是，暂且按下不表，再看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhangguoa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/3/17 9:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().pass(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;main: &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pass</span> <span class="params">(StringBuilder str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;pass: &quot;</span> +  str);</span><br><span class="line">        str = str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pass: zhangsan</span><br><span class="line">main: zhangsan</span><br></pre></td></tr></table></figure>

<p>可以看出，这里我们直接对形参str的值进行改变，但是并未改变str的原值，说明并没有起到效果，这符合值传递的定义，再看一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zhangguoa</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/3/17 9:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().pass(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;main: &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pass</span> <span class="params">(StringBuilder str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;pass: &quot;</span> +  str);</span><br><span class="line">        str.append(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实到这里就很明显了，形参str就是传入参数str的复制值，二者引用的是堆中的同一个对象，所以可以通过改变指向的对象的值来进行一些属性值的改变，但是无法通过形参改变原参数的值，大概像下面这样。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ol>
<li>loading（装载）</li>
<li>linking（链接）</li>
<li>initialization（初始化）</li>
<li>类的Using（使用）</li>
<li>类的unloading（卸载）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403170903172.png" alt="image-20240317090348592"></p>
<p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类写在出内存为止，它的整个生命周期包括如上7阶段。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>一个类只能由一个类的加载器加载一次，但可以使用其他的类的加载器重新加载，实现类的隔离。</p>
<h4 id="loading（装载）"><a href="#loading（装载）" class="headerlink" title="loading（装载）"></a>loading（装载）</h4><p>将Java类的二进制文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。</p>
<p><strong>操作</strong></p>
<p>查找并加载类的二进制数据，生成Class的实例。</p>
<p>Java虚拟机必须完成以下3件事：</p>
<ul>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java类模型）</li>
<li>创建java.lang.Clas的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p><strong>类模板对象：</strong></p>
<p>就是Java类在JVM内存中的一个快照，JVM将从字节码文件中接续出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够以对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>
<p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM 在运行期也无法反射。</p>
<p><strong>类模型的位置</strong> </p>
<p>加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDK1.8之前：永久代；JDK1.8及之后：元空间）</p>
<h5 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h5><p>多种途径获得，只要所读取的字节码符合JVM规范即可</p>
<ul>
<li>读入class文件</li>
<li>读入jar、zip等归档数据包，提取类文件</li>
<li>实现存放在数据库中的类的二进制数据</li>
<li>使用了类似于HTTP之类的协议通过网络进行加载</li>
<li>在运行时生成一段Class的二进制信息。</li>
</ul>
<p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终祝你各位一个java.lang.Class的实例</p>
<p>如果输入数据不是ClassFile的结构，则会抛出ClassRoematError。</p>
<h5 id="Class实例的位置在哪"><a href="#Class实例的位置在哪" class="headerlink" title="Class实例的位置在哪"></a>Class实例的位置在哪</h5><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403170936348.png" alt="image-20240317093632139"></p>
<p>注：Class类的构造方法是私有的，只有JVM可以创建，java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的接口，可以获得目标类关联的.class文件中具体的数据结构：方法、字段等信息。</p>
<h5 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h5><p>数组类本身并不是有类加载器负责创建的，而是由JVM在运行时根据需要直接创建的，加载器只加载数组的元素类型。</p>
<ol>
<li>如果数组的元素类型时引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素新类型；</li>
<li>JVM使用指定的元素类型和数组为度来创建新的数组类。</li>
<li>如果数组的元素类型是引用类型，数组类的可访问性就有元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</li>
</ol>
<h4 id="Linking-链接"><a href="#Linking-链接" class="headerlink" title="Linking 链接"></a>Linking 链接</h4><h5 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证 Verification"></a>验证 Verification</h5><p>验证格式、语义检查、字节码验证、符号引用验证。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403171054423.png" alt="image-20240317105402818"></p>
<h5 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备 Preparation"></a>准备 Preparation</h5><p>简言之，为<strong>类的静态变量分配内存</strong>，并将其<strong>初始化为默认值</strong>。</p>
<p>在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。</p>
<p><strong>注</strong>：</p>
<ol>
<li>这里不包含基本数据类型的字段用<strong>static final</strong>修饰的情况，应为<strong>final在编译的时候就会分配</strong>了，准备阶段会显式赋值</li>
<li>注意这里不会为实例变量分配初始化，实例变量时会随着对象一起分配到Java堆中</li>
<li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li>
</ol>
<h5 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析 Resolution"></a>解析 Resolution</h5><p>将类、接口、字段和方法的符号引用转为直接引用。</p>
<h4 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization 初始化"></a>Initialization 初始化</h4><p>为<strong>静态变量</strong>赋予正确的<strong>初始值</strong>。</p>
<p>类的初始话是类装载的最后一个阶段，如果前面的步骤都没有问题，那么表示类可以再梳理的装载到系统中。此时，<strong>类才会开始执行Java字节码（到了初始化阶段，才真正开始执行类中定义的Java程序代码。）</strong></p>
<p>初始化阶段的重要工作是<strong>执行类的初始化方法：&lt; clinit &gt;()方法。</strong></p>
<ul>
<li>该方法<strong>仅能由Java编译器生成</strong>并<strong>由JVM调用</strong>，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是由<strong>类静态成员的赋值语句</strong>以及<strong>static语句块</strong>合并产生的。</li>
</ul>
<p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的clinnit总是在子类clinit之前被调用，也就是说，父类的static块优先级高于子类</p>
<p>由父及子，静态先行。</p>
<h5 id="哪些类不会生成clinit方法？"><a href="#哪些类不会生成clinit方法？" class="headerlink" title="哪些类不会生成clinit方法？"></a>哪些类不会生成clinit方法？</h5><ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。</li>
<li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。</li>
</ul>
<h5 id="static-final搭配时不一定不生成clinit方法"><a href="#static-final搭配时不一定不生成clinit方法" class="headerlink" title="static final搭配时不一定不生成clinit方法"></a>static final搭配时不一定不生成clinit方法</h5><p>当该变量的值需要点用某种方法来赋值或者涉及其它在初始化阶段赋值的变量时，static final修饰的变量还是会生成clinit方法来赋值。</p>
<h5 id="clinit-方法有带锁线程安全处理"><a href="#clinit-方法有带锁线程安全处理" class="headerlink" title="&lt; clinit &gt;方法有带锁线程安全处理"></a>&lt; clinit &gt;方法有带锁线程安全处理</h5><p>虚拟机会保证一个类的cllinit方法在多线程中正确加锁、同步。</p>
<p>如果多个线程同时区初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待。</p>
<p>可能会造成多个线程阻塞，引发死锁。</p>
<h5 id="类的初始化情况，主动使用和被动使用"><a href="#类的初始化情况，主动使用和被动使用" class="headerlink" title="类的初始化情况，主动使用和被动使用"></a>类的初始化情况，主动使用和被动使用</h5><p>Java程序对类的使用分为两种：主动使用和被动使用。</p>
<h5 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h5><p><strong>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件的装载Class类。</strong></p>
<p>Java虚拟机规定，<strong>一个类或接口在初次使用前，必须要进行初始化</strong>。这里的<strong>使用是指主动使用</strong>。</p>
<p>主动使用只有以下几种情况（如果出现如下的情况，则会对类进行初始化操作，而初始化操作之前的而加载、验证、准备已经完成。）</p>
<ol>
<li>当<strong>创建一个类的实例</strong>时，比如使用new关键字，或者通过反射、克隆、反序列化</li>
<li>当<strong>调用类的静态方法</strong>时，即当使用了字节码invokestatic指令。</li>
<li>当<strong>使用类、接口的静态字段</strong>时（final修饰特殊考虑），比如，使用getstatuc或者putstatuc指令</li>
<li>当使用<strong>反射类的方法</strong>时，<strong>Class.forName(“”);</strong></li>
<li>当<strong>初始化子类</strong>时，如果发现器父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>如果一个接口<strong>定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</strong>。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的<strong>主类（包含main方法的类）</strong>，<strong>虚拟机会先初始化这个主类</strong>。</li>
</ol>
<h4 id="Unloading-卸载"><a href="#Unloading-卸载" class="headerlink" title="Unloading 卸载"></a>Unloading 卸载</h4><h5 id="类、类的加载器、类的实例之间的关系"><a href="#类、类的加载器、类的实例之间的关系" class="headerlink" title="类、类的加载器、类的实例之间的关系"></a>类、类的加载器、类的实例之间的关系</h5><p>在类的加载器的内部实现中，用一个人Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader方法，就能获得它的类加载器。由此可见，待变某个类的Class实例预期类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用还表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class 对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403200942146.png" alt="image-20240320094157209"></p>
<h5 id="什么情况下类会被卸载"><a href="#什么情况下类会被卸载" class="headerlink" title="什么情况下类会被卸载"></a>什么情况下类会被卸载</h5><p>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当代表类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束类的生命周期。</p>
<h5 id="类卸载在实际生产中的情况"><a href="#类卸载在实际生产中的情况" class="headerlink" title="类卸载在实际生产中的情况"></a>类卸载在实际生产中的情况</h5><ul>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问得到。</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾手机功能才可以做到。可以预想，复杂的应用场景中，被加载的类型在运行期间是几乎不太可能被卸载的。</li>
</ul>
<p><strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。</strong></p>
<h5 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h5><p>方法区的垃圾回收主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的二类的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSSG、JSP的重加在等，否则通常是很难达成的。</li>
<li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一样，没有了引用就必然会回收。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403201340054.png" alt="image-20240320134006047"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>类加载器是JVM执行类加载机制的前提。</p>
<h5 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h5><p>ClassLoader是Java的信心组件，<strong>所有的Class都是由ClassLoader进行加载的</strong>。</p>
<p>ClassLoader负责通过各种方式将Class信息的二进制数据读入JVM内部，转换为一个与目标类对用的java.lang.Class对象实例。然后交给Java虚拟机进行连接、初始化等操作。</p>
<p>因此，<strong>ClassLoader在整个装在阶段，只能影响到类的加载</strong>，而无法通过ClassLoader区改变类的连接和初始化行为。至于她是否可以运行，则由Execution Engine决定。</p>
<h4 id="类的显式加载和隐式加载"><a href="#类的显式加载和隐式加载" class="headerlink" title="类的显式加载和隐式加载"></a>类的显式加载和隐式加载</h4><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<ul>
<li><p>显式加载：指的是在代码中通过调用ClassLoader加载class对象，如直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLass.forName(name)或this.getClass().getClassLoader.loadClass()</span><br></pre></td></tr></table></figure>

<p>加载class对象</p>
</li>
<li><p>隐式加载：则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载的内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
</li>
</ul>
<p>在日常开发中以上两种方式一般会混合使用。</p>
<h4 id="类加载机制的必要性"><a href="#类加载机制的必要性" class="headerlink" title="类加载机制的必要性"></a>类加载机制的必要性</h4><p>一般情况下，Java开发人员不需要在程序中显式的使用类加载器，但了解类加载器的加载机制缺显得至关重要。</p>
<ul>
<li>避免在开发遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDeFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速的根据错误异常日志定位问题和解决问题。</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器类冲洗你定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h4 id="加载的类是唯一的吗"><a href="#加载的类是唯一的吗" class="headerlink" title="加载的类是唯一的吗"></a>加载的类是唯一的吗</h4><h5 id="1-类的唯一性"><a href="#1-类的唯一性" class="headerlink" title="1.类的唯一性"></a>1.类的唯一性</h5><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等。只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类原子同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<h5 id="2-命名空间"><a href="#2-命名空间" class="headerlink" title="2.命名空间"></a>2.命名空间</h5><ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及其所有的父加载器锁加载的类组成。</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整没名字（包括类的包名）相同的两个类。</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h4 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h4><p>通常类加载机制有三个基本特征</p>
<ul>
<li><strong>双亲委派模型</strong>：但不是所有的类都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProbider&#x2F;ServiceLoader机制，用户可以在标准框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中的JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li><strong>可见性</strong>：<strong>子类加载器可以访问父加载器加载的类型</strong>，但是反过来是不允许的，不然因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li><strong>单一性</strong>：<strong>由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载</strong>。但是注意，<strong>类加载器“邻居”之间，同一类型仍然可以被加载多次，因为互相并不可见。</strong></li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型是Java类加载器在加载类时遵循的一个核心原则。这种模型规定，<strong>每当一个类加载器收到加载请求时</strong>，它首先不会自己去尝试加载这个类，而是<strong>把请求委派到父类加载器去完成</strong>。每一层类加载器都是如此，除非<strong>父加载器在其搜索范围内找不到对应的类，或者明确反馈没有父加载器，子加载器自己才会尝试去加载。</strong></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211045799.png" alt="image-20240321104536911"></p>
<p>具体来说，双亲委派模型的工作过程如下;</p>
<ol>
<li><strong>若一个类加载器收到了类加载的请求，他爱首先不会自己区尝试加载这个类，而是把这个请求委派给父加载器。</strong></li>
<li><strong>递归向上委派，直到委派到了启动类加载器</strong>，启动类加载器是最顶层的类加载器。</li>
<li><strong>启动类加载器检测是都能够加载这个类。能加载就结束，不加载返回给子加载器</strong>。</li>
<li>重复步骤三，如果<strong>下层的加载器在它的搜索范围内也没有找到对应的类，就会回到委派这个类加载任务的加载器，告诉它找不到这个类。</strong></li>
<li>如果<strong>所有的父类加载器都不能完成这个加载，那么子加载器就会尝试自己去加载</strong>。</li>
</ol>
<p>这种机制涉及的主要目的是为<strong>了保护Java的核心API不会被外部篡改和污染</strong>，并且**确保了Java类的唯一性通过网络下载的一个类并不会替换掉系统内部预定义的类。具有亲子关系的类加载器可以共享已经加载过的类，这种方式可以有效地节省资源，提高效率。</p>
<h3 id="类加载器的分类和测试"><a href="#类加载器的分类和测试" class="headerlink" title="类加载器的分类和测试"></a>类加载器的分类和测试</h3><h4 id="类加载器的分类说明"><a href="#类加载器的分类说明" class="headerlink" title="类加载器的分类说明"></a>类加载器的分类说明</h4><p>JVM支持两种类型的类加载器，分别为引导类加载器和自定义类加载器。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader 的类加载器都划分为自定义加载器。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403201530865.png" alt="image-20240320153035315"></p>
<p>启动类加载器是使用c或c++语言编写的。</p>
<h4 id="子父类加载器的关系"><a href="#子父类加载器的关系" class="headerlink" title="子父类加载器的关系"></a>子父类加载器的关系</h4><ul>
<li>处了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</li>
<li>不同类加载器看似是继承关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
<li>一般来讲是将父加载器注入到子加载器内</li>
</ul>
<h4 id="具体类加载器介绍"><a href="#具体类加载器介绍" class="headerlink" title="具体类加载器介绍"></a>具体类加载器介绍</h4><h5 id="启动类加载器（引导类加载器）"><a href="#启动类加载器（引导类加载器）" class="headerlink" title="启动类加载器（引导类加载器）"></a>启动类加载器（引导类加载器）</h5><ul>
<li>使用c&#x2F;c++实现，嵌套在JVM内部</li>
<li>用来加载Java的核心库如<code>&lt;JAVA_HOME&gt;/jre/lib/rt.jar</code>中的类或者系统属性<code>sun.boot.class.path</code>路径中的类库。</li>
<li>并不继承自java.lang.Classloader，没有父加载器。</li>
<li>出于安全考虑，Bootsttrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为它们的父类加载器。</li>
</ul>
<h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><ul>
<li>Java语言</li>
<li>继承于ClassLoader</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<h5 id="应用程序类加载器（系统类加载器）"><a href="#应用程序类加载器（系统类加载器）" class="headerlink" title="应用程序类加载器（系统类加载器）"></a>应用程序类加载器（系统类加载器）</h5><ul>
<li>Java语言</li>
<li>继承与ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>应用程序中的类加载器默认是系统类加载器。</li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器。</li>
</ul>
<h5 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h5><ul>
<li><strong>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的</strong>，在必要时，我们还可以自定义类加载器，来定制类的加载方式</li>
<li>体现Java语言强大生命力和巨大魅力的关键元素之一便是，<strong>Java开发者可以自定义类加载器来实现类库的动态加载</strong>，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制，类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现。</li>
<li>同时，<strong>自定义加载器能够实现应用隔离</strong>，例如Tomcat、Spring等中间件和组件框架都再内部实现类自定义的加载器，并<strong>通过自定义加载器隔离不同的组件模块</strong>。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C+++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性就可以挡住所有美好的设想</li>
<li>所有用户自定义类加载器通常需要继承于抽象类java.lang.classloader</li>
</ul>
<h3 id="ClassLoader源码剖析"><a href="#ClassLoader源码剖析" class="headerlink" title="ClassLoader源码剖析"></a>ClassLoader源码剖析</h3><h4 id="类加载器的分类说明-1"><a href="#类加载器的分类说明-1" class="headerlink" title="类加载器的分类说明"></a>类加载器的分类说明</h4><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211040517.png" alt="image-20240321104016859"></p>
<h3 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h3><ul>
<li><p><strong>隔离加载类</strong></p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如，阿里某容器看框架通过自定义加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p>
</li>
<li><p><strong>修改类加载方式</strong></p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个事件点进行按需进行动态加载。</p>
</li>
<li><p><strong>扩展加载源</strong></p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
</li>
<li><p><strong>防止源码泄露</strong></p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211256629.png" alt="image-20240321125645973"></p>
<p>定义</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211257951.png" alt="image-20240321125756923"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>双亲委派机制在<code>java.lang .ClassLoader.loadClass(String,boolean)</code>接口中体现，该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass(name.false)</code>接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassOrNull(name)</code>接口，让引导类加载器进行加载。</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用<code>java.lang.ClassLoader</code>接口的<code>sefineClass</code>系列的native接口加载目标Java类</li>
</ol>
<h4 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父亲已经加载了该类时，就没必要子ClassLoader再加载一次。</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改。</p>
</li>
</ul>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><p>检查类是否加载的委托模式是单向的，这个方式会导致顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类夹在其中。这是，就会出现该工厂方法无法创建有应用类加载器加载的应用实例的问题。</p>
<h4 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h4><h5 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h5><p>双亲委派模型的第一次被破坏其实发生在双亲委派模型出现之前，即JDK1.2面世之前的远古时代。</p>
<p>由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类<code>java.lang.ClassLoader</code>则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型的是偶不得不做出一些妥协，为了兼容这些已有代码，无法在以技术手段避免<code>loadCLass()</code>被子类覆盖的可能性，只能在JDK1.2之后的<code>java.langClassloader</code>中添加一个新的protected方法<code>findClass（）</code>，并引导用户编写类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass()</code>中编写代码。双亲委派机制的具体逻辑就实现在<code>loadClass()</code>中，按照<code>loadClass()</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findCLass()</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派机制的。</p>
<h5 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h5><p>双亲委派机制很好的解决了各个类加载器协作的时候基础类型的一致性问题，越基础的类由越上层的加载器进行加载</p>
<p>基础类型之所以被称为基础，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变得完美规则，如果有基础类型又要调回用户的代码，那该怎么办呢。</p>
<p>JDNI服务就是一个例子，它的代码由启动类加载器来完成加载，属于基础类型类，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口的代码，现在的问题是启动类加载器是不可能认识并加载这些代码的，那该怎么办？</p>
<p>稳了解决这个问题，Java设计团队引入了一个不太优雅的设计：<strong>线程上下文类加载器</strong>，这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程是还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211449217.png"></p>
<h5 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h5><p><strong>代码热替换和模块热部署</strong></p>
<p>IBM公司主导的JSR-291 即OSGI 实现模块化热部署的关键是他自定义的类加载机制的实现，每一个程序模块都有一个自己的类加载器，当需要更换一个Bundle的时候，就把Bundle联通类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不在双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGI将按照下面的顺序进行类搜索：</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211453112.png" alt="image-20240321145354875"></p>
<h2 id="运行时内存"><a href="#运行时内存" class="headerlink" title="运行时内存"></a>运行时内存</h2><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211511295.png" alt="image-20240321151155101"></p>
<img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211518821.png" alt="image-20240321151810625" style="zoom: 200%;" />

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403211524465.png" alt="image-20240321152422044" style="zoom:200%;" />

<p>为什么需要它</p>
<ul>
<li>为了保证指令能够连续的执行下去，CPU必须具有某些手段来确定下一条指令的地址。程序计数器正起到这种作用，所以通常又称为指令计数器。</li>
<li>在程序开始执行之前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器PC的内容即是从内存提取到的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每一条指令PC增加一个两，这个量等于指令所含的字节数，以便使其保持的总是将要执行的吓一跳指令的地址。</li>
<li>由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1.</li>
<li>当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，一次实现转移。有些机器中也称PC为指令指针IP。</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这个计数器来完成。</li>
<li>PC寄存器用来存储指向下一条指令的的地址，也即将要执行的指令代码。执行引擎的字节码解释器工作时就是通过改变</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403230926137.png" alt="image-20240323092559446"></p>
<p> <strong>栈比堆快，堆比栈大。</strong></p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="如何理解栈管运行，堆管存储"><a href="#如何理解栈管运行，堆管存储" class="headerlink" title="如何理解栈管运行，堆管存储"></a>如何理解栈管运行，堆管存储</h5><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231618416.png" alt="image-20240323161815437"></p>
<h5 id="栈中存在GC吗"><a href="#栈中存在GC吗" class="headerlink" title="栈中存在GC吗"></a>栈中存在GC吗</h5><p>不存在，但存在OOM溢出。</p>
<h5 id="栈会爆出什么异常"><a href="#栈会爆出什么异常" class="headerlink" title="栈会爆出什么异常"></a>栈会爆出什么异常</h5><ul>
<li>Java虚拟机规范中允许<strong>Java栈的大小是动态的或者是固定不变的</strong>。<ul>
<li>如果采用固定大小的虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程是没有足够的内存区创建对应的虚拟机栈，拿Java虚拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
</ul>
<h5 id="栈会在什么情况下发生栈内存溢出"><a href="#栈会在什么情况下发生栈内存溢出" class="headerlink" title="栈会在什么情况下发生栈内存溢出"></a>栈会在什么情况下发生栈内存溢出</h5><ul>
<li>局部数组过大</li>
<li>递归调用层次太多。递归单数在运行时会执行延展操作，当压栈次数太多时，也会导致堆栈溢出。</li>
</ul>
<h5 id="Java中，栈的大小通过什么参数来设置"><a href="#Java中，栈的大小通过什么参数来设置" class="headerlink" title="Java中，栈的大小通过什么参数来设置"></a>Java中，栈的大小通过什么参数来设置</h5><p>在Java中，每一个线程的栈大小是通过JVM启动参数来设置的。</p>
<p>你可以使用<code>-Xss</code>参数来设置每个线程的栈大小。比如，你可以设置<code>-Xss1m</code>来将栈大小设置为1M（1MB）。</p>
<p>以下是具体例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss1m ClassName</span><br></pre></td></tr></table></figure>

<p>上述命令将为运行的Java程序中的每个线程分配1MB的栈空间。</p>
<p>需要注意的是，不同平台的JVM实现对<code>-Xss</code>参数的默认值可能不同。在某些情况下，如果设置一个太大或太小的值可能会导致OutOfMemoryError或者其他内存相关的错误。因此，需要根据具体的应用场景和硬件环境进行适当的设置。</p>
<p>与之相关的还有<code>-Xms</code>和<code>-Xmx</code>参数，分别用于设置Java堆的初始大小和最大大小。这两个参数与栈大小设置无关，但同样重要。堆空间主要用于存放对象实例，其大小设置会直接影响到程序的性能。</p>
<p><strong>设置的栈空间值过大</strong>，<strong>会导致系统可以用于创建线程的数量减少</strong>。</p>
<p><strong>一般一个进程中通常有3000~5000个线程。</strong></p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>方法和栈帧之间存在怎样的关系？</p>
<ul>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231609671.png" alt="image-20240323160927575"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231610941.png" alt="image-20240323160959901"></p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧时有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在站的顶端，称为新的当前帧。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<h5 id="栈的FILO原理"><a href="#栈的FILO原理" class="headerlink" title="栈的FILO原理"></a>栈的FILO原理</h5><p>JVM直接对Java栈进行的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>遵循先进后出，后进先出的原则。</p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈桢之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧回传会此方法的执行结果给前一个栈桢，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><ul>
<li>局部变量表</li>
<li>操作数栈（或表达式栈）</li>
<li>动态链接（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231631020.png" alt="image-20240323163140973"></p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li>定义为一个数字数组，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括基本数据类型、对象引用、以及returnAdress类型</li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maxinum local vatiables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的占空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法抵用结束后，随着方法栈帧的小欧会，局部变量表也会随之销毁。</li>
</ul>
<h6 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h6><ul>
<li><strong>参数分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</strong></li>
<li>我们知道类变量表有两次初始化机会，第一次实在<strong>准备阶段，执行系统初始化，对类变量设置零值</strong>，另一次则是在<strong>初始化阶段，赋予程序员在代码中定义的初始值。</strong></li>
<li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着<strong>一旦定义了局部变量则必须人为初始化</strong>，否则无法使用。</li>
</ul>
<h6 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h6><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403231914792.png" alt="image-20240323191454073"></p>
<h6 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h6><p>在JVM中，<strong>Slot是局部变量表的存储单元</strong>。局部变量表是变量值存储空间，为JVM执行方法服务。</p>
<p>其主要功能如下：</p>
<ol>
<li><strong>存储局部变量：</strong>执行Java方法时，JVM使用Slot来存储方法的局部变量。这些局部变量包括各种基本类型、对象引用，以及返回地址等。</li>
<li><strong>控制方法的参数</strong>：对于实例方法，第0个Slot默认是用于存储this指针。如果是静态方法则没有this指针。其余的Slot用来传递参数，</li>
<li><strong>提供存储空间复用</strong>：Slot可以重复使用，JVM中的方法在执行过程中，如果局部变量过期或无效，那么该变量占用的Slot上会用来存储其他的局部变量值。</li>
</ol>
<p>在JVM惊醒垃圾收集时，能确定哪些对象已经过期(即不再有任何引用指向这些对象)，进一步提高内存利用率。判断依据就是这些过期<strong>对象的引用是否还存放在某个方法的局部变量表的Slot中。如果没有，这个对象就可以被判断为过期。</strong></p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><ul>
<li><strong>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的是操作数栈</strong></li>
<li>每一个独立的栈帧中处了包含局部变量表意外，还包含一个后进先出的操作数栈，也可以称之为表达式栈</li>
<li><strong>操作数栈就是JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</li>
<li><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了</strong>，保存在方法的Code属性中，为max_stack的值</li>
<li><strong>栈中的任何一个元素都是可以任意的Java数据类型</strong><ul>
<li><strong>32bit的类型占用一个栈单位深度</strong></li>
<li><strong>64bit的类型占用两个栈单位深度</strong></li>
</ul>
</li>
<li>操作数栈，在方法执行过程中，根据字节码指令，<strong>并非采用访问索引的方式来进行数据访问的，而是只能用过标准的入栈和出栈操作，往栈中写入数据或提取数据来完成一次数据访问</strong><ul>
<li><strong>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</strong></li>
</ul>
</li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配。这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
</ul>
<h6 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h6><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派次数和内存读写次数。</p>
<p>由于操作数使存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM地设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU地寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p>
<h5 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h5><ul>
<li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法地引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如”invokedynamic”指令。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件地常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li>
</ul>
<h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>一个方法的结束，有两种方式：<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>无论通过哪种方式退出，在方法腿粗回收都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的。返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法放回值的数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
</li>
<li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p>
<p>方法在执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
</li>
</ol>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设计PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和一场完成出口的区别在于：通过异常完成出口退出不会给他的上层调用者产生任何的异常返回值。</p>
<h4 id="问题和小结"><a href="#问题和小结" class="headerlink" title="问题和小结"></a>问题和小结</h4><h5 id="栈溢出的情况"><a href="#栈溢出的情况" class="headerlink" title="栈溢出的情况"></a>栈溢出的情况</h5><p>栈溢出：StackOverflowError</p>
<p>栈的大小可以是固定大小的，也可以是动态变化的。</p>
<p>如果是固定的，可以通过-Xss设置栈的大小；</p>
<p>如果是动态变化的，当栈大小到达了整个内存空间不足了，就是抛出OutOfMemory异常</p>
<h5 id="分配的栈内存越大越好吗？"><a href="#分配的栈内存越大越好吗？" class="headerlink" title="分配的栈内存越大越好吗？"></a>分配的栈内存越大越好吗？</h5><p>不是，因为增加栈的大小，会造成每个线程的栈都变得很大，使得一定的栈空间下，能创建的线程数量就会变小</p>
<h5 id="垃圾回收是否会涉及到虚拟机栈"><a href="#垃圾回收是否会涉及到虚拟机栈" class="headerlink" title="垃圾回收是否会涉及到虚拟机栈"></a>垃圾回收是否会涉及到虚拟机栈</h5><p>不会；</p>
<p>垃圾回收只会涉及到方法区和堆中，方法区和堆也会存在溢出的可能</p>
<p>程序计数器，只记录运行下一行的地址，不存在溢出和垃圾回收</p>
<p>虚拟机栈和本地方法栈，都是只涉及压栈和出战，可能存在栈溢出，不存在垃圾回收。</p>
<h5 id="方法中定义的局部变量是否线程安全"><a href="#方法中定义的局部变量是否线程安全" class="headerlink" title="方法中定义的局部变量是否线程安全"></a>方法中定义的局部变量是否线程安全</h5><p>如果不会被其他方法调用的话就是线程安全的，如果是作为参数出入方法的话，就是线程不安全的。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="核心概述"><a href="#核心概述" class="headerlink" title="核心概述"></a>核心概述</h3><ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</li>
<li>堆内存的大小是可以调节的</li>
<li>Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该是被视为连续的，</li>
<li>堆，是GC执行垃圾回收的重点区域。</li>
<li>在方法结束后，堆中的对象不会马上被溢出，仅仅在垃圾收集的时候才会被移除</li>
</ul>
<h5 id="对象都分配在堆上？"><a href="#对象都分配在堆上？" class="headerlink" title="对象都分配在堆上？"></a>对象都分配在堆上？</h5><p>Java虚拟机规范的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。数组和对象可能永远不会存储在栈上，应为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p><strong>注</strong>：</p>
<p>在虚拟机调优中涉及“<strong>栈上分配技术</strong>”，这种技术就是将一些只在当前方法使用的变量直接放在栈上，运行速度快且不用GC。</p>
<p><strong>所有的线程都共享堆？</strong></p>
<p>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）。</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251828909.png" alt="image-20240325182853127"></p>
<h3 id="堆的内部结构"><a href="#堆的内部结构" class="headerlink" title="堆的内部结构"></a>堆的内部结构</h3><p>现代垃圾收集器大部分都基于分代手机理论设计，对空间细分为：<br><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251855790.png" alt="image-20240325185523566"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251857199.png" alt="image-20240325185701971"></p>
<h4 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h4><ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以分为年轻代和老年代</p>
</li>
<li><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也成为from区和to区）</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251924323.png" alt="image-20240325190044777"></p>
</li>
<li><p>几乎所有的Java对象都是在Eden区被new出来的。</p>
</li>
<li><p>绝大部分的Java对象的销毁都是在新生代进行的</p>
</li>
</ul>
<h3 id="如何设置堆内存的大小"><a href="#如何设置堆内存的大小" class="headerlink" title="如何设置堆内存的大小"></a>如何设置堆内存的大小</h3><ul>
<li><p>可以通过-Xmx和-Xms来设置</p>
<ul>
<li>-Xms用于表示堆区的起始内存</li>
<li>-Xmx用于表示堆区的最大内存</li>
</ul>
</li>
<li><p>通常会将这两个参数设置为相同的值，目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p>
</li>
<li><p>heap默认最大值计算方式：如果物理内存少于192M，那么heap最大值为物理内存的一般。如果物理内存大于等于1G，那么heap最大值为物理内存的1&#x2F;4.</p>
</li>
<li><p>heap默认最小值：最少不得少于8M，如果物理内存大于等于1G，那么默认值为物理内存的1&#x2F;64.最小堆内存在jvm启动的时候就会被初始化。</p>
</li>
</ul>
<h4 id="新生代和老年代的比例"><a href="#新生代和老年代的比例" class="headerlink" title="新生代和老年代的比例"></a>新生代和老年代的比例</h4><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403251923096.png" alt="image-20240325192356622"></p>
<p>默认新生代站1&#x2F;3，老年代占2&#x2F;3</p>
<p>一般不调</p>
<h4 id="Eden，幸存者区比例"><a href="#Eden，幸存者区比例" class="headerlink" title="Eden，幸存者区比例"></a>Eden，幸存者区比例</h4><p>8：1：1</p>
<h3 id="对象分配金句"><a href="#对象分配金句" class="headerlink" title="对象分配金句"></a>对象分配金句</h3><ul>
<li>针对s0, s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：<ul>
<li>频繁在新生区收集</li>
<li>很少在养老区收集</li>
<li>几乎不在永久区&#x2F;元空间收集</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261712182.png" alt="image-20240326171254213"></p>
<h4 id="内存分配原则"><a href="#内存分配原则" class="headerlink" title="内存分配原则"></a>内存分配原则</h4><p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序内出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果Survivor区中相同年龄的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenurThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h4 id="过程剖析"><a href="#过程剖析" class="headerlink" title="过程剖析"></a>过程剖析</h4><ol>
<li>new的对象先放在伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC&#x2F;YGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园区的剩余对象移动到s0区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</li>
<li>啥时候能去养老区呢，可以设置次数。默认是十五次</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<h3 id="详细解释Minor-GC-Major-GC-Full-GC"><a href="#详细解释Minor-GC-Major-GC-Full-GC" class="headerlink" title="详细解释Minor GC, Major GC, Full GC"></a>详细解释Minor GC, Major GC, Full GC</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261754315.png" alt="image-20240326175411623"></p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>JVM再进行GC的时候，并非每次都对上面三个内存（新生代、老年代、方法区）一起回收的，大部分时候回收的都是新生代</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大钟类型：</p>
<ul>
<li>一种时部分收集</li>
<li>一种是整堆收集（Full GC）</li>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC, Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC, Old GC）只是老年代的垃圾收集<ul>
<li>目前只有CMS GC会有单独收集老年代的行为</li>
<li>很多时候Major GC会和Full GC混淆使用，需要分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集 Full GC：收集整个Java堆和方法区的垃圾收集</li>
</ul>
<h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ul>
<li><p>Minor GC触发机制</p>
<ul>
<li><p>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满</p>
<p>Survivor满不会触发GC。每次MinorGC会清理年轻代的内存。</p>
</li>
<li><p>因为Java对象大多具备朝生夕灭的特许，所以Minor GC非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才回复运行。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261808361.png" alt="image-20240326180836505"></p>
<h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>老年代GC触发机制：</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说Major GC或Full GC发生了。<ul>
<li>出现了Major GC，经常会伴随至少一次的Minor GC。</li>
<li>也就是在老年代空间不足时，会先尝试触发MinorGC, 如果之后空间还是不足，则触发MajorGC</li>
</ul>
</li>
<li>MajorGC的速度一般会比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC之后，内存还是不足，就报OOM了。</li>
</ul>
<h4 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h4><ul>
<li>调用<code>System.gc()</code>时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的品骏大小大于老年代的可用内存</li>
<li>由Eden区，survivor 0 和 survivor 1区复制时，对象大小大于To 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>
</ul>
<p>说明：Full gc时开发或调优中尽量要避免的，这样暂停时间会短一些。</p>
<h3 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h3><p>分代的唯一理由就是优化GC性能。如果没有分代，拿所有的对象都在一块，就如同八月一个学校的人都关在一个教室。GC的时候要找到哪些对象没有，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话 ，把新创建的对象放到某一地方，当GC的是偶先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><ul>
<li>从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li>
<li>基本上所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261926363.png" alt="image-20240326192628923"></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h4 id="栈、堆、方法区的关系"><a href="#栈、堆、方法区的关系" class="headerlink" title="栈、堆、方法区的关系"></a>栈、堆、方法区的关系</h4><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261927932.png" alt="image-20240326192727105"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261927965.png" alt="image-20240326192735177"></p>
<h3 id="方法区在哪里"><a href="#方法区在哪里" class="headerlink" title="方法区在哪里"></a>方法区在哪里</h3><p>方法区逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。</p>
<p>对于HotSpotJVM而言，方法区还有一个别名叫做非堆，目的就是要和堆分开</p>
<p>所以，方法区看作是一块独立于Java堆的内存空间</p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261932444.png" alt="image-20240326193220958"></p>
<h3 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h3><p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261943930.png" alt="image-20240326194306558"></p>
<ul>
<li>方法区与堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且他的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，更对空间一样，可以 选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法去溢出，虚拟机同样会抛出内存溢出错误</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><ul>
<li>在jdk7及以前，习惯上把方法区，称为永久代，jdk8开始，使用元空间取代了永久代。</li>
<li>本质上，方法区和永久代并不等价。仅对hotspot而言的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261939744.png" alt="image-20240326193949788"></p>
<ul>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用了JRockit，J9一样在本地内存中实现的元空间来代替。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。步过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。</li>
<li>永久代、元空间并不只是名字不同，内部结构也调整了</li>
<li>方法区无法满足新的内存分配需求时，抛出OOM异常</li>
</ul>
<h3 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h3><h4 id="永久代为什么要被元空间替换"><a href="#永久代为什么要被元空间替换" class="headerlink" title="永久代为什么要被元空间替换"></a>永久代为什么要被元空间替换</h4><ul>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统的可用内存空间。</li>
</ul>
<p>这项改动的原因：</p>
<ul>
<li><p>为永久代设置空间大小是很难确定的</p>
<p>在某些场景下，如果动态加载类过多，容易产生perm区的OOM。比如某个实际web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误</p>
<p>而元空间由于并不在虚拟机中而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li><p>对永久代进行调优是很困难的</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261954985.png" alt="image-20240326195448291"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261955908.png" alt="image-20240326195504397"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403261955632.png" alt="image-20240326195521097"></p>
<p><img src="https://raw.githubusercontent.com/baiyina/baiyina.github.image/main/img/202403262021178.png" alt="image-20240326202053671"></p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><h4 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h4><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><ul>
<li>new</li>
<li>静态方法</li>
<li>XxxBuilder&#x2F;XxxFactory的静态方法</li>
</ul>
<h5 id="Class的newInstance"><a href="#Class的newInstance" class="headerlink" title="Class的newInstance"></a>Class的newInstance</h5><p>反射的方式，只能调用空参的构造器，权限必须是public</p>
<h5 id="Constructor的newInstance-Xxx"><a href="#Constructor的newInstance-Xxx" class="headerlink" title="Constructor的newInstance(Xxx)"></a>Constructor的newInstance(Xxx)</h5><p>反射，可以调用空参，带参的构造器，权限没有要求，实用性更强</p>
<h5 id="使用Clone（）"><a href="#使用Clone（）" class="headerlink" title="使用Clone（）"></a>使用Clone（）</h5><p>不调用任何构造器，当前类需要实现Cloneable接口，实现clone，默认浅拷贝</p>
<h5 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h5><p>从文件、数据库、网络中获取一个对象的二进制流，反序列化为内存中的对象</p>
<h5 id="第三方库Objenesis"><a href="#第三方库Objenesis" class="headerlink" title="第三方库Objenesis"></a>第三方库Objenesis</h5><p>利用了asm字节码技术，动态生成Constructor对象</p>
<h4 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h4>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        

    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">baiyina</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">22k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">40 mins.</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
